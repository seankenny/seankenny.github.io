<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web Api | Sean Kenny]]></title>
  <link href="http://www.seankenny.me/blog/categories/web-api/atom.xml" rel="self"/>
  <link href="http://www.seankenny.me/"/>
  <updated>2014-07-23T19:32:16+01:00</updated>
  <id>http://www.seankenny.me/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deserialisation and Constructor Logic Don't Mix]]></title>
    <link href="http://www.seankenny.me/blog/2014/06/10/deserialisation-and-constructor-logic-dont-mix/"/>
    <updated>2014-06-10T20:11:00+01:00</updated>
    <id>http://www.seankenny.me/blog/2014/06/10/deserialisation-and-constructor-logic-dont-mix</id>
    <content type="html"><![CDATA[<p>I got caught on this one last week. I was load testing a web api resource using ApacheBench and was getting some really bad perf figures in the region of 40 req/sec when I would have expected an order of magnitude more at least.  The data model being sent as JSON was:</p>

<!--more-->


<p>```c#
public class LogMessage
{</p>

<pre><code>    public ulong PhysicalMemory { get; set; }
    // lots more properties

    public LogMessage()
    {
              var ci = new ComputerInfo();
              AvailablePhysicalMemory = ci.AvailablePhysicalMemory;
    }
</code></pre>

<p>}
<code>``
When deserialising the request body into the dataModel, the constructor gets called and we have the overhead of the **slow**</code>ComputerInfo().AvailablePhysicalMemory` call to get the available memory of the machine.  Multiply this in a load test scenario and there&rsquo;s the culprit.</p>

<p>The fix is simple:</p>

<p>```c#
public class LogMessage
{</p>

<pre><code>    public ulong AvailablePhysicalMemory { get; set; }

    public void Init()
    {
              var ci = new ComputerInfo();
              AvailablePhysicalMemory = ci.AvailablePhysicalMemory;
    }
</code></pre>

<p>}
```</p>

<p>The client changes to:</p>

<p><code>c#
var message = new LogMessage().Init();
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web Api With Dot in the Route]]></title>
    <link href="http://www.seankenny.me/blog/2014/06/04/web-api-with-dot-in-the-route/"/>
    <updated>2014-06-04T17:58:00+01:00</updated>
    <id>http://www.seankenny.me/blog/2014/06/04/web-api-with-dot-in-the-route</id>
    <content type="html"><![CDATA[<p>We have a requirement to have a dot midway in a route for one of our web api services.  The route looks something like <code>http://localhost/api/some.route/person</code>.  The controller (if using attribute based routing) is:</p>

<p>```c#
[RoutePrefix(&ldquo;api/some.route&rdquo;)]
public class UsersController : ApiController
{
  [Route(&ldquo;person&rdquo;)]
  public HttpResponseMessage Person(int id)
  {</p>

<pre><code>// do stuff
</code></pre>

<p>  }
}
<code>``
 &lt;!--more--&gt;
When you try to hit this resource using fiddler or postman, you'll get a 404 not found error.  There are plenty of StackOverflow posts out there about having dots in the route but these mainly are to do with a dot at the end of the route rather than midway so something like</code><a href="http://localhost/api/someroute/per.son">http://localhost/api/someroute/per.son</a>`.  IIS will identify the dot and assume you are after a static file with an extension of &lsquo;son&rsquo;.  To get around this, you can add this to your web.config file as explained by <a href="http://haacked.com/archive/2010/04/29/allowing-reserved-filenames-in-URLs.aspx">Phil Haack</a>.</p>

<p><code>xml
&lt;system.web&gt;
  &lt;httpRuntime relaxedUrlToFileSystemMapping="true" /&gt;
</code></p>

<p>However this will not work where the dot is midway in the URL like I have.  For me, adding the following resolves the issue (although not having to have a dot in the route would be the obvious solution but sometimes your hands are tied).</p>

<p>```xml
&lt;system.webServer>
  <handlers></p>

<pre><code>&lt;add name="UrlRoutingHandler" type="System.Web.Routing.UrlRoutingHandler, System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" path="some.route/*" verb="*"/&gt;
</code></pre>

<p>```</p>

<p>Adding this post as I <strong>KNOW</strong> I will forget this!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS XSRF in .Net Land - SlidingExpiration]]></title>
    <link href="http://www.seankenny.me/blog/2014/01/22/angularjs-xsrf-in-net-land-slidingexpiration/"/>
    <updated>2014-01-22T19:52:00+00:00</updated>
    <id>http://www.seankenny.me/blog/2014/01/22/angularjs-xsrf-in-net-land-slidingexpiration</id>
    <content type="html"><![CDATA[<p>So we have <a href="http://seankenny.me/blog/2014/01/20/angularjs-xsrf-in-net-land/">XSRF built into our app</a> and all is well.  Now we set the slidingExpiration=&ldquo;true&rdquo; in our web.config file:
<code>xml
&lt;authentication mode="Forms"&gt;
  &lt;forms loginUrl="~/Account/Login" timeout="2880" slidingExpiration="true" /&gt;
&lt;/authentication&gt;
</code></p>

<!--more-->


<p>This will automatically update the authentication cookie once the cookie is nearing it&rsquo;s expiry time.  That way, if a user is on the site continuously then they will not need to re-authenticate.  This is a security flaw but real world requirements sometimes mean we need to be flexible.</p>

<p>When ASP.Net detects the authentication cookie needs to be refreshed, it creates a new authentication cookie with a new value.  Now when we check the X-XSRF-TOKEN request header value sent to us by angular as part of a POST request, the values will not match up.  The user will start getting 401 exceptions after a time.</p>

<p>To get around this, we will need to implement the sliding exipiration functionality ourselves.</p>

<p>Remove the web.config <code>slidingExpiration="true"</code> attribute.</p>

<p>In the global.asax:</p>

<p>```c#
protected void Application_PostAuthenticateRequest(object sender, EventArgs e)
{</p>

<pre><code>var authCookie = HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName];
SlidingExpirationCookie(authCookie);
</code></pre>

<p>}
private void SlidingExpirationCookie(HttpCookie authCookie)
{</p>

<pre><code>if (authCookie == null)
{
    return;
}

var ticket = FormsAuthentication.Decrypt(authCookie.Value);
var newTicket = FormsAuthentication.RenewTicketIfOld(ticket);
if (newTicket == null || newTicket.Expiration == ticket.Expiration)
{
    return;
}

var encryptedTicket = FormsAuthentication.Encrypt(newTicket);
authCookie = new HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket)
{
    Secure = FormsAuthentication.RequireSSL,
    Path = FormsAuthentication.FormsCookiePath,
    Domain = FormsAuthentication.CookieDomain,
    HttpOnly = true
};

if (ticket.IsPersistent)
{
    authCookie.Expires = ticket.Expiration;
}

Response.Cookies.Add(authCookie);

var csrfToken = new CsrfTokenHelper().GenerateCsrfTokenFromAuthToken(authCookie.Value);
var csrfCookie = new HttpCookie("FORM-XSRF", csrfToken) // remember, we don't use the default XSRF-TOKEN cookie name
{
    HttpOnly = false,
    Secure = authCookie.Secure,
    Path = authCookie.Path,
    Domain = authCookie.Domain
};

HttpContext.Current.Response.Cookies.Add(csrfCookie);
</code></pre>

<p>}
```</p>

<p>Now the authentication cooke and the XSRF cookie will stay in sync.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS XSRF in .Net Land]]></title>
    <link href="http://www.seankenny.me/blog/2014/01/20/angularjs-xsrf-in-net-land/"/>
    <updated>2014-01-20T18:31:00+00:00</updated>
    <id>http://www.seankenny.me/blog/2014/01/20/angularjs-xsrf-in-net-land</id>
    <content type="html"><![CDATA[<p>Ah yes, <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a>.</p>

<p>So the basics are we need to ensure that the content of a POST request is coming from our site and has not been intercepted by a ne'er-do-well.</p>

<p>In ASP.Net MVC it&rsquo;s pretty straighforward.  In your Razor file, just add an <code>Html.AntiForgeryToken()</code> into the form in question and then, on the action, add a <code>[ValidateAntiForgeryToken]</code> filter and all is well.</p>

<!--more-->


<p>For angularjs and web api, things are different.  First off, we are using HTML files and not razor cshtml files so we cannot use the <code>Hml.AntiForgeryToken()</code> helper method.</p>

<p>So this is the way I have done it using the FormsAuthentication cookie (kudos to this <a href="http://stackoverflow.com/questions/15574486/angular-against-asp-net-webapi-implement-csrf-on-the-server">SO</a> post.  Check it out &ndash; all you need is in there.  Remember to up-vote!).</p>

<p>1)  Add a <code>XSRF-TOKEN</code> cookie.  The value of this cookie is obtained from the authorization cookie.
AngularJs, by default, will search for this cookie when POSTing data back to the server.  When it finds it, it will add a <code>X-XSRF-TOKEN</code> header to the request.</p>

<p>2) When we receive a POST request, we add a <code>[ValidateXSRFToken]</code> filter which will look for the <code>X-XSRF-TOKEN</code> request header then compare it to the authentication cookie value to see if there is a match.</p>

<p>If there is no match, we return a <code>401 Unauthorized</code> response.</p>

<p>Now for us, we cannot use a cookie names <code>XSRF-TOKEN</code> for reasons I won&rsquo;t go into.  So we can alter this in the server side code easily and then set the angularjs code to use this name rather than the default <code>XSRF-TOKEN</code> name.  we do this in the angular.module().config section of the code:</p>

<p>```js
angular.module(&lsquo;myApp&rsquo;, [])</p>

<pre><code>.config(['$httpProvider', function ($httpProvider) {
    $httpProvider.defaults.xsrfCookieName = 'FORM-XSRF';
});
</code></pre>

<p>```</p>

<p>Now angular will tie up nicely to the XSRF cookie change.</p>

<p>If you need to change the POST request header from <code>X-XSRF-TOKEN</code> you can use:
<code>js
$httpProvider.defaults.xsrfHeaderName  = 'X-FORM-XSRF';
</code></p>

<p>Next, what happens when you <a href="http://seankenny.me/blog/2014/01/22/angularjs-xsrf-in-net-land-slidingexpiration/">introduce <code>slidingExpiration="true"</code> into the mix</a>?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CamelCaseJson]]></title>
    <link href="http://www.seankenny.me/blog/2014/01/05/camelcasejson/"/>
    <updated>2014-01-05T10:49:00+00:00</updated>
    <id>http://www.seankenny.me/blog/2014/01/05/camelcasejson</id>
    <content type="html"><![CDATA[<p>I prefer JSON camel cased.  The default setup in ASP.net Web Api using the Newtonsoft JsonSerializer is for Pascal Case.  To switch to camel case is easy and makes for a much more seamless angularJS and Web Api interaction.  In the WebAPiConfig class:</p>

<p><code>c#
var jsonFormatter = GlobalConfiguration.Configuration.Formatters.JsonFormatter;
jsonFormatter.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
</code></p>
]]></content>
  </entry>
  
</feed>
